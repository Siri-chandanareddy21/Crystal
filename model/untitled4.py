# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13eMoxKhntbu9u-JkF0Yodg8OlIkb5_mT
"""

# cell: data_preprocess.py
import os
import numpy as np
import json
from pymatgen.core import Structure
from pymatgen.io.cif import CifParser


DATA_DIR = '/mnt/data/chemical_system/chemical_system/' # Corrected data directory
OUT_DIR = '/mnt/data/processed/'
os.makedirs(OUT_DIR, exist_ok=True)


# Helper: parse CIF or custom format
def parse_cif_file(path):
    parser = CifParser(path)
    structure = parser.get_structures(primitive=False)[0]
    return structure


# Convert to tensors: composition one-hot (or fractional), lattice 3x3, fractional coords, species indices
ELEMENTS = ['H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P','S','Cl','Ar','K','Ca', # extend as needed
]
EL_TO_IDX = {e:i for i,e in enumerate(ELEMENTS)}
MAX_ATOMS = 64


def structure_to_example(structure, target_spacegroup=None):
    # composition vector
    comp = structure.composition
    comp_vec = np.zeros(len(ELEMENTS), dtype=np.float32)
    for el, amt in comp.get_el_amt_dict().items():
        if el in EL_TO_IDX:
            comp_vec[EL_TO_IDX[el]] = amt
    # lattice matrix
    lattice = np.array(structure.lattice.matrix, dtype=np.float32) # (3,3)
    # fractional positions (pad to MAX_ATOMS)
    frac = np.zeros((MAX_ATOMS,3), dtype=np.float32)
    species = np.full((MAX_ATOMS,), -1, dtype=np.int64)
    coords = structure.frac_coords
    for i,site in enumerate(structure.sites):
        if i>=MAX_ATOMS: break
        frac[i] = coords[i]
        el = site.specie.symbol
        species[i] = EL_TO_IDX.get(el, -1)
    # spacegroup as integer label (use spglib or pymatgen)
    sg = target_spacegroup if target_spacegroup is not None else structure.get_space_group_info()[1]
    return {
        'comp_vec': comp_vec.tolist(),
        'lattice': lattice.tolist(),
        'frac': frac.tolist(),
        'species': species.tolist(),
        'spacegroup': sg
    }


# Walk dataset
examples = []
for root, dirs, files in os.walk(DATA_DIR):
    for f in files:
        if f.lower().endswith('.cif'):
            try:
                s = parse_cif_file(os.path.join(root,f))
                ex = structure_to_example(s)
                examples.append(ex)
            except Exception as e:
                print('failed', f, e)


# Save processed JSON
with open(os.path.join(OUT_DIR,'examples.json'),'w') as fh:
    json.dump(examples, fh)


print('Processed', len(examples))

!pip install pymatgen



# cell: data_preprocess.py
import os
import numpy as np
import json
from pymatgen.core import Structure
from pymatgen.io.cif import CifParser


DATA_DIR = '/mnt/data/chemical_system/chemical_system/' # Corrected data directory
OUT_DIR = '/mnt/data/processed/'
os.makedirs(OUT_DIR, exist_ok=True)


# Helper: parse CIF or custom format
def parse_cif_file(path):
    parser = CifParser(path)
    structure = parser.get_structures(primitive=False)[0]
    return structure


# Convert to tensors: composition one-hot (or fractional), lattice 3x3, fractional coords, species indices
ELEMENTS = ['H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P','S','Cl','Ar','K','Ca', # extend as needed
]
EL_TO_IDX = {e:i for i,e in enumerate(ELEMENTS)}
MAX_ATOMS = 64


def structure_to_example(structure, target_spacegroup=None):
    # composition vector
    comp = structure.composition
    comp_vec = np.zeros(len(ELEMENTS), dtype=np.float32)
    for el, amt in comp.get_el_amt_dict().items():
        if el in EL_TO_IDX:
            comp_vec[EL_TO_IDX[el]] = amt
    # lattice matrix
    lattice = np.array(structure.lattice.matrix, dtype=np.float32) # (3,3)
    # fractional positions (pad to MAX_ATOMS)
    frac = np.zeros((MAX_ATOMS,3), dtype=np.float32)
    species = np.full((MAX_ATOMS,), -1, dtype=np.int64)
    coords = structure.frac_coords
    for i,site in enumerate(structure.sites):
        if i>=MAX_ATOMS: break
        frac[i] = coords[i]
        el = site.specie.symbol
        species[i] = EL_TO_IDX.get(el, -1)
    # spacegroup as integer label (use spglib or pymatgen)
    sg = target_spacegroup if target_spacegroup is not None else structure.get_space_group_info()[1]
    return {
        'comp_vec': comp_vec.tolist(),
        'lattice': lattice.tolist(),
        'frac': frac.tolist(),
        'species': species.tolist(),
        'spacegroup': sg
    }


# Walk dataset
examples = []
for root, dirs, files in os.walk(DATA_DIR):
    for f in files:
        if f.lower().endswith('.cif'):
            try:
                s = parse_cif_file(os.path.join(root,f))
                ex = structure_to_example(s)
                examples.append(ex)
            except Exception as e:
                print('failed', f, e)


# Save processed JSON
with open(os.path.join(OUT_DIR,'examples.json'),'w') as fh:
    json.dump(examples, fh)


print('Processed', len(examples))

!pip install pymatgen

from google.colab import files
uploaded = files.upload()

# Unzip dataset (adjust path if necessary)
!unzip -o /content/chemical_system.zip -d /mnt/data/chemical_system/

!unzip -o chemical_system.zip -d /content/chemical_system/

import os
os.makedirs('/content/checkpoints', exist_ok=True)
os.makedirs('/content/out', exist_ok=True)
os.makedirs('/content/processed', exist_ok=True)

# cell: model_cvae.py
import torch
import torch.nn as nn
import torch.nn.functional as F

# Assuming N_ELEM and LATENT_DIM are defined elsewhere
# from data_preprocess import MAX_ATOMS, ELEMENTS, EL_TO_IDX

# Define dummy values for N_ELEM and LATENT_DIM if they are not defined in the context
try:
    N_ELEM = len(ELEMENTS)
except NameError:
    N_ELEM = 20 # Or the appropriate number of elements you are considering

try:
    LATENT_DIM = 128 # Or your desired latent dimension
except NameError:
    LATENT_DIM = 128

try:
    MAX_ATOMS = MAX_ATOMS
except NameError:
    MAX_ATOMS = 64


class SpaceGroupEmbedding(nn.Module):
    def __init__(self, max_sg=230, emb_dim=64): # max_sg=230 for all space groups
        super().__init__()
        self.embed = nn.Embedding(max_sg+1, emb_dim)

    def forward(self, x):
        return self.embed(x)


class Encoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.sg_emb = SpaceGroupEmbedding()
        # encode lattice (flatten 9) + frac coords (MAX_ATOMS*3) + species one-hot (MAX_ATOMS*N_ELEM)
        in_dim = 9 + MAX_ATOMS*3 + MAX_ATOMS*N_ELEM
        self.fc1 = nn.Linear(in_dim + 64, 512)
        self.fc_mu = nn.Linear(512, LATENT_DIM)
        self.fc_logvar = nn.Linear(512, LATENT_DIM)


    def forward(self, lattice, frac, species_oh, sg_idx):
        # lattice: (B,3,3) -> (B,9)
        x = torch.cat([lattice.view(lattice.size(0), -1), frac.view(frac.size(0), -1), species_oh.view(species_oh.size(0), -1)], dim=-1)
        sg_e = self.sg_emb(sg_idx)
        x = torch.cat([x, sg_e], dim=-1)
        h = F.relu(self.fc1(x))
        return self.fc_mu(h), self.fc_logvar(h)


class Decoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.sg_emb = SpaceGroupEmbedding()
        out_dim = 9 + MAX_ATOMS*3 + MAX_ATOMS*N_ELEM
        self.fc1 = nn.Linear(LATENT_DIM + 64, 512)
        self.fc_out = nn.Linear(512, out_dim)


    def forward(self, z, sg_idx):
        sg_e = self.sg_emb(sg_idx)
        x = torch.cat([z, sg_e], dim=-1)
        h = F.relu(self.fc1(x))
        out = self.fc_out(h)
        # split to lattice, frac, species logits
        lattice = out[:, :9].view(-1,3,3)
        frac = out[:,9:9+MAX_ATOMS*3].view(-1,MAX_ATOMS,3)
        species_logits = out[:,9+MAX_ATOMS*3:].view(-1,MAX_ATOMS,N_ELEM)
        return lattice, frac, species_logits


class CVAE(nn.Module):
    def __init__(self):
        super().__init__()
        self.enc = Encoder()
        self.dec = Decoder()


    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5*logvar)
        eps = torch.randn_like(std)
        return mu + eps*std


    def forward(self, lattice, frac, species_oh, sg_idx):
        mu, logvar = self.enc(lattice, frac, species_oh, sg_idx)
        z = self.reparameterize(mu, logvar)
        lattice_rec, frac_rec, species_logits = self.dec(z, sg_idx)
        return lattice_rec, frac_rec, species_logits, mu, logvar

import os
from pymatgen.io.cif import CifParser

DATA_DIR_UNZIPPED = '/mnt/data/chemical_system/chemical_system/'
structures = []

def parse_cif_file(path):
    parser = CifParser(path)
    structure = parser.get_structures(primitive=False)[0]
    return structure

for root, dirs, files in os.walk(DATA_DIR_UNZIPPED):
    for f in files:
        if f.lower().endswith('.cif'):
            try:
                cif_path = os.path.join(root, f)
                structure = parse_cif_file(cif_path)
                structures.append(structure)
            except Exception as e:
                print(f'Failed to parse {f}: {e}')

print(f'Loaded {len(structures)} structures.')

import torch
from torch.utils.data import Dataset, DataLoader
import json
from tqdm import trange
import os # Import os


class CrystalDataset(Dataset):
    def __init__(self, json_path):
        with open(json_path) as fh:
            self.data = json.load(fh)
    def __len__(self):
        return len(self.data)
    def __getitem__(self, idx):
        ex = self.data[idx]
        lattice = torch.tensor(ex['lattice'], dtype=torch.float32)
        frac = torch.tensor(ex['frac'], dtype=torch.float32)
        species = torch.tensor(ex['species'], dtype=torch.long)
        # species one-hot
        species_oh = torch.zeros((MAX_ATOMS, N_ELEM), dtype=torch.float32)
        for i,s in enumerate(species):
            if s>=0:
                species_oh[i,s]=1.0
        sg_label = ex['spacegroup']
        return lattice, frac, species_oh, sg_label


# Setup
ds = CrystalDataset('/mnt/data/processed/examples.json')
loader = DataLoader(ds, batch_size=8, shuffle=True)


model = CVAE()
opt = torch.optim.Adam(model.parameters(), lr=1e-3)


def loss_fn(lattice_pred, frac_pred, species_logits, lattice_true, frac_true, species_oh, mu, logvar):
    # lattice MSE
    l_lattice = F.mse_loss(lattice_pred, lattice_true)
    # fractional coordinates MSE (only on atoms present). We'll create mask from species_oh
    mask = (species_oh.sum(-1) > 0).unsqueeze(-1).float()
    l_frac = F.mse_loss(frac_pred*mask, frac_true*mask)
    # species cross entropy
    species_target = species_oh.argmax(-1)
    species_pred = species_logits.permute(0,2,1) # (B, N_ELEM, MAX_ATOMS)
    l_species = F.cross_entropy(species_logits.reshape(-1,N_ELEM), species_target.reshape(-1), ignore_index=-1)
    # KL
    kl = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp()) / mu.size(0)
    return l_lattice + l_frac + l_species + 1e-3*kl, {'lat':l_lattice.item(), 'frac':l_frac.item(), 'spec':l_species.item(), 'kl':kl.item()}

# Create checkpoints directory if it doesn't exist
os.makedirs('/mnt/data/checkpoints', exist_ok=True)

# Training (minimal)
for epoch in range(10):
    model.train()
    pbar = trange(len(loader))
    for i, batch in enumerate(loader):
        lattice, frac, species_oh, sg_label = batch
        lattice_pred, frac_pred, species_logits, mu, logvar = model(lattice, frac, species_oh, sg_label)
        loss, parts = loss_fn(lattice_pred, frac_pred, species_logits, lattice, frac, species_oh, mu, logvar)
        opt.zero_grad(); loss.backward(); opt.step()
        pbar.set_description(f"ep{epoch} loss {loss.item():.4f}")
    torch.save(model.state_dict(), '/content/checkpoints/cvae_latest.pt')



print('Training complete')

!mkdir /mnt/data/checkpoints

import torch
from pymatgen.core import Structure, Lattice, Composition, Species
import numpy as np


model = CVAE()
model.load_state_dict(torch.load('/content/checkpoints/cvae_latest.pt')) # Corrected path
model.eval()


def sample_composition_vector(comp_dict):
    vec = np.zeros(len(ELEMENTS), dtype=np.float32)
    for el,amt in comp_dict.items():
        if el in EL_TO_IDX:
            vec[EL_TO_IDX[el]] = amt
    return vec


def infer_structure(spacegroup_idx:int, comp_dict:dict, num_atoms:int=8, temperature=1.0):
    # For this simple CVAE we ignore comp_vec conditioning in decoder; a more advanced model would condition on comp too.
    z = torch.randn((1,LATENT_DIM)) * temperature
    sg_idx = torch.tensor([spacegroup_idx], dtype=torch.long)
    lat_pred, frac_pred, species_logits = model.dec(z, sg_idx)
    lat = lat_pred.detach().numpy()[0]
    frac = frac_pred.detach().numpy()[0]
    # species_indices = species_logits.detach().numpy()[0].argmax(-1) # Old: sampled species

    # New: Use elements from comp_dict for species
    elements_from_comp = list(comp_dict.keys())
    num_elements = len(elements_from_comp)
    species_symbols = [elements_from_comp[i % num_elements] for i in range(num_atoms)]


    # Build pymatgen Structure
    lattice = Lattice(lat)
    sites = []
    # We need to map species indices back to element symbols
    idx_to_el = {i: e for e, i in EL_TO_IDX.items()}

    for i in range(num_atoms): # Use num_atoms to limit the number of sites
        # species_idx = species_indices[i] # Old: sampled species
        species_symbol = species_symbols[i] # New: Use species from comp_dict
        # if species_idx != -1 and species_idx < len(ELEMENTS): # Old check
        if species_symbol in ELEMENTS: # New check
             # species_symbol = idx_to_el[species_idx] # Old mapping
             sites.append( {'species': [ { "element": species_symbol, "occu": 1 } ], 'abc': frac[i].tolist() } )

    if not sites:
        print("Warning: No valid sites generated for the specified number of atoms and species.")
        return None

    # Create a Composition object from comp_dict for validation/information purposes if needed
    # comp = Composition(comp_dict) # Not directly used in structure creation this way

    try:
        structure = Structure.from_dict({
            'lattice': lattice.as_dict(),
            'sites': sites,
            'charge': 0 # Assuming neutral structure, adjust if needed
        })
        return structure
    except Exception as e:
        print(f"Failed to create structure: {e}")
        return None

# Example usage
# Generate a new structure with different parameters
# Let's try spacegroup 225, composition FeO, and 8 atoms
import os

# Create the output directory if it doesn't exist
os.makedirs('/mnt/data/out/', exist_ok=True)

s = infer_structure(225, {'Fe':1, 'O':1}, num_atoms=8)

if s:
    s.to(filename='/mnt/data/out/generated_new.cif')
    print("✅ Generated CIF saved at /mnt/data/out/generated_new.cif")
else:
    print("❌ Failed to generate structure with the specified parameters.")

import torch
from pymatgen.core import Structure, Lattice, Composition, Species
import numpy as np


model = CVAE()
model.load_state_dict(torch.load('/content/checkpoints/cvae_latest.pt')) # Corrected path
model.eval()


def sample_composition_vector(comp_dict):
    vec = np.zeros(len(ELEMENTS), dtype=np.float32)
    for el,amt in comp_dict.items():
        if el in EL_TO_IDX:
            vec[EL_TO_IDX[el]] = amt
    return vec


def infer_structure(spacegroup_idx:int, comp_dict:dict, num_atoms:int=8, temperature=1.0):
    # For this simple CVAE we ignore comp_vec conditioning in decoder; a more advanced model would condition on comp too.
    z = torch.randn((1,LATENT_DIM)) * temperature
    sg_idx = torch.tensor([spacegroup_idx], dtype=torch.long)
    lat_pred, frac_pred, species_logits = model.dec(z, sg_idx)
    lat = lat_pred.detach().numpy()[0]
    frac = frac_pred.detach().numpy()[0]
    # species_indices = species_logits.detach().numpy()[0].argmax(-1) # Old: sampled species

    # New: Use elements from comp_dict for species
    elements_from_comp = list(comp_dict.keys())
    num_elements = len(elements_from_comp)
    species_symbols = [elements_from_comp[i % num_elements] for i in range(num_atoms)]


    # Build pymatgen Structure
    lattice = Lattice(lat)
    sites = []
    # We need to map species indices back to element symbols
    idx_to_el = {i: e for e, i in EL_TO_IDX.items()}

    for i in range(num_atoms): # Use num_atoms to limit the number of sites
        # species_idx = species_indices[i] # Old: sampled species
        species_symbol = species_symbols[i] # New: Use species from comp_dict
        # if species_idx != -1 and species_idx < len(ELEMENTS): # Old check
        if species_symbol in ELEMENTS: # New check
             # species_symbol = idx_to_el[species_idx] # Old mapping
             sites.append( {'species': [ { "element": species_symbol, "occu": 1 } ], 'abc': frac[i].tolist() } )

    if not sites:
        print("Warning: No valid sites generated for the specified number of atoms and species.")
        return None

    # Create a Composition object from comp_dict for validation/information purposes if needed
    # comp = Composition(comp_dict) # Not directly used in structure creation this way

    try:
        structure = Structure.from_dict({
            'lattice': lattice.as_dict(),
            'sites': sites,
            'charge': 0 # Assuming neutral structure, adjust if needed
        })
        return structure
    except Exception as e:
        print(f"Failed to create structure: {e}")
        return None

!pip install py3Dmol
!pip install ase

from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor
import py3Dmol
import os

def visualize_cif_3d(cif_path, bond_radius=0.15, atom_radius=0.3):
    # Load structure with pymatgen
    try:
        structure = Structure.from_file(cif_path)
    except FileNotFoundError:
        print(f"Error: The file {cif_path} was not found.")
        return None, None
    except Exception as e:
        print(f"Error loading structure from {cif_path}: {e}")
        return None, None

    # Convert to ASE atoms
    atoms = AseAtomsAdaptor.get_atoms(structure)

    # Build XYZ string for py3Dmol
    xyz_str = f"{len(atoms)}\n\n"
    for a in atoms:
        xyz_str += f"{a.symbol} {a.position[0]:.6f} {a.position[1]:.6f} {a.position[2]:.6f}\n"

    # 3Dmol viewer
    view = py3Dmol.view(width=500, height=500)
    view.addModel(xyz_str, 'xyz')
    # Use sphere representation for atoms and bond representation for connections with custom radii
    view.setStyle({'sphere':{'radius': atom_radius}, 'bond':{'radius': bond_radius}})
    view.zoomTo()
    display(view.show()) # Use display to show the py3Dmol view

    return structure, view

# Specify the path to the generated CIF file
generated_cif_file = "/mnt/data/out/generated_new.cif"

# Re-run infer_structure with the specified composition (Optional, keep if you want to regenerate)
s = infer_structure(225, {'Fe':1, 'O':1}, num_atoms=8)

if s:
    s.to(filename=generated_cif_file)
    print("✅ Generated CIF saved at", generated_cif_file)
    # Visualize the generated CIF file and get the structure object
    structure, view = visualize_cif_3d(generated_cif_file)
    if structure:
        print("\nChemical Formula:", structure.formula)
    else:
        print("\nCould not determine chemical formula as structure loading failed.")

else:
    print("❌ Failed to generate structure with the specified parameters.")

import os
import random
from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor
import py3Dmol

def visualize_cif_3d(cif_path, bond_radius=0.15, atom_radius=0.3, viewer_id="viewer"):
    # Load structure with pymatgen
    try:
        structure = Structure.from_file(cif_path)
    except FileNotFoundError:
        print(f"Error: The file {cif_path} was not found.")
        return None, None
    except Exception as e:
        print(f"Error loading structure from {cif_path}: {e}")
        return None, None

    # Convert to ASE atoms
    atoms = AseAtomsAdaptor.get_atoms(structure)

    # Build XYZ string for py3Dmol
    xyz_str = f"{len(atoms)}\n\n"
    for a in atoms:
        xyz_str += f"{a.symbol} {a.position[0]:.6f} {a.position[1]:.6f} {a.position[2]:.6f}\n"

    # 3Dmol viewer
    view = py3Dmol.view(width=500, height=500)
    view.addModel(xyz_str, 'xyz')
    # Add sphere representation for atoms
    view.addStyle({'sphere':{'radius': atom_radius}})
    # Add bond representation for connections
    view.addStyle({'bond':{'radius': bond_radius}})
    view.zoomTo()
    display(view.show()) # Use display to show the py3Dmol view

    return structure, view


# Select a random original CIF file from the unzipped data
data_dir_unzipped = '/mnt/data/chemical_system/chemical_system/'
cif_files = [os.path.join(root, f) for root, dirs, files in os.walk(data_dir_unzipped) for f in files if f.lower().endswith('.cif')]

if cif_files:
    random_cif_file = random.choice(cif_files)
    print(f"Visualizing original structure from: {random_cif_file}")
    original_structure, original_view = visualize_cif_3d(random_cif_file, bond_radius=0.15, atom_radius=0.3)

    if original_structure:
        print("\nOriginal Structure Chemical Formula:", original_structure.formula)
    else:
        print("\nCould not determine original structure chemical formula.")
else:
    print("No CIF files found in the original data directory.")

import os
import torch
from pymatgen.core import Structure, Lattice, Composition, Species
import numpy as np
import json

# Load the processed data to get unique space groups and compositions
processed_data_path = '/mnt/data/processed/examples.json'
unique_spacegroups = set()
unique_compositions = set()

try:
    with open(processed_data_path, 'r') as fh:
        data = json.load(fh)
        for example in data:
            unique_spacegroups.add(example['spacegroup'])
            # Convert composition vector back to a dictionary for uniqueness check
            comp_dict = {}
            for i, count in enumerate(example['comp_vec']):
                if count > 0 and i < len(ELEMENTS):
                    comp_dict[ELEMENTS[i]] = count
            # Represent composition as a sorted tuple of (element, count) pairs for hashing
            unique_compositions.add(tuple(sorted(comp_dict.items())))

    print(f"Found {len(unique_spacegroups)} unique space groups and {len(unique_compositions)} unique compositions in the dataset.")

except FileNotFoundError:
    print(f"Error: Processed data file not found at {processed_data_path}. Please run the data preprocessing step.")
    unique_spacegroups = []
    unique_compositions = []
except Exception as e:
    print(f"Error loading processed data: {e}")
    unique_spacegroups = []
    unique_compositions = []


# Ensure the CVAE model is loaded
try:
    model
except NameError:
    print("Loading CVAE model...")
    model = CVAE()
    model.load_state_dict(torch.load('/mnt/data/checkpoints/cvae_latest.pt'))
    model.eval()

# Define output directory
OUT_DIR_GENERATED = '/mnt/data/out/'
os.makedirs(OUT_DIR_GENERATED, exist_ok=True)

# Generate and save structures for each unique space group and composition
if unique_spacegroups and unique_compositions:
    print("Generating structures...")
    generated_count = 0
    # For demonstration, we will generate one structure for each unique composition using a common spacegroup (e.g., the first one found)
    # A more comprehensive approach would iterate through all combinations or sample based on frequency

    # Get the first unique spacegroup
    if unique_spacegroups:
        example_spacegroup = list(unique_spacegroups)[0]
        print(f"Using spacegroup {example_spacegroup} for all generated structures.")

        for comp_tuple in list(unique_compositions):
            comp_dict = dict(comp_tuple)
            # Check if comp_dict is empty before proceeding
            if not comp_dict:
                print(f"Skipping generation for empty composition.")
                continue

            # Generate structure
            # The inputs are: spacegroup_idx, comp_dict, num_atoms, temperature
            s = infer_structure(example_spacegroup, comp_dict, num_atoms=8, temperature=1.0)

            if s:
                # Create a filename based on composition and spacegroup
                comp_string = "".join([f"{el}{int(amt) if amt == int(amt) else amt}" for el, amt in comp_dict.items()])
                filename = f"{comp_string}_sg{example_spacegroup}_generated.cif"
                file_path = os.path.join(OUT_DIR_GENERATED, filename)
                s.to(filename=file_path)
                print(f"✅ Generated CIF saved at {file_path}")
                generated_count += 1
            else:
                print(f"❌ Failed to generate structure for composition {comp_dict} and spacegroup {example_spacegroup}.")

        print(f"\nFinished generating and saving {generated_count} structures.")
    else:
        print("No unique spacegroups found to generate structures.")
else:
    print("Could not find unique space groups or compositions from the processed data.")

import os
import random
from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor
import py3Dmol

def visualize_cif_3d(cif_path, bond_radius=0.15, atom_radius=0.3, viewer_id="viewer"):
    # Load structure with pymatgen
    try:
        structure = Structure.from_file(cif_path)
    except FileNotFoundError:
        print(f"Error: The file {cif_path} was not found.")
        return None, None
    except Exception as e:
        print(f"Error loading structure from {cif_path}: {e}")
        return None, None

    # Convert to ASE atoms
    atoms = AseAtomsAdaptor.get_atoms(structure)

    # Build XYZ string for py3Dmol
    xyz_str = f"{len(atoms)}\n\n"
    for a in atoms:
        xyz_str += f"{a.symbol} {a.position[0]:.6f} {a.position[1]:.6f} {a.position[2]:.6f}\n"

    # 3Dmol viewer
    view = py3Dmol.view(width=500, height=500)
    view.addModel(xyz_str, 'xyz')
    # Add sphere representation for atoms
    view.addStyle({'sphere':{'radius': atom_radius}})
    # Add bond representation for connections
    view.addStyle({'bond':{'radius': bond_radius}})
    view.zoomTo()
    display(view.show()) # Use display to show the py3Dmol view

    return structure, view


# Select a random generated CIF file from the output folder
generated_data_dir = '/mnt/data/out/'
generated_cif_files = [os.path.join(root, f) for root, dirs, files in os.walk(generated_data_dir) for f in files if f.lower().endswith('.cif')]

if generated_cif_files:
    random_generated_cif_file = random.choice(generated_cif_files)
    print(f"Visualizing generated structure from: {random_generated_cif_file}")
    generated_structure, generated_view = visualize_cif_3d(random_generated_cif_file, bond_radius=0.15, atom_radius=0.3)

    if generated_structure:
        print("\nGenerated Structure Chemical Formula:", generated_structure.formula)
    else:
        print("\nCould not determine generated structure chemical formula.")
else:
    print("No generated CIF files found in the output directory.")

import os
import random
from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor
import py3Dmol

def visualize_cif_3d(cif_path, bond_radius=0.15, atom_radius=0.3, viewer_id="viewer"):
    # Load structure with pymatgen
    try:
        structure = Structure.from_file(cif_path)
    except FileNotFoundError:
        print(f"Error: The file {cif_path} was not found.")
        return None, None
    except Exception as e:
        print(f"Error loading structure from {cif_path}: {e}")
        return None, None

    # Convert to ASE atoms
    atoms = AseAtomsAdaptor.get_atoms(structure)

    # Build XYZ string for py3Dmol
    xyz_str = f"{len(atoms)}\n\n"
    for a in atoms:
        xyz_str += f"{a.symbol} {a.position[0]:.6f} {a.position[1]:.6f} {a.position[2]:.6f}\n"

    # 3Dmol viewer
    view = py3Dmol.view(width=500, height=500)
    view.addModel(xyz_str, 'xyz')
    # Add sphere representation for atoms
    view.addStyle({'sphere':{'radius': atom_radius}})
    # Add bond representation for connections
    view.addStyle({'bond':{'radius': bond_radius}})
    view.zoomTo()
    display(view.show()) # Use display to show the py3Dmol view

    return structure, view


# Select a random original CIF file from the unzipped data
data_dir_unzipped = '/mnt/data/chemical_system/chemical_system/'
cif_files = [os.path.join(root, f) for root, dirs, files in os.walk(data_dir_unzipped) for f in files if f.lower().endswith('.cif')]

if cif_files:
    random_cif_file = random.choice(cif_files)
    print(f"Visualizing original structure from: {random_cif_file}")
    original_structure, original_view = visualize_cif_3d(random_cif_file, bond_radius=0.15, atom_radius=0.3)

    if original_structure:
        print("\nOriginal Structure Chemical Formula:", original_structure.formula)
    else:
        print("\nCould not determine original structure chemical formula.")
else:
    print("No CIF files found in the original data directory.")

!ls /mnt/data/out/

"""Support for third party widgets will remain active for the duration of the session. To disable support:"""

!pip install nglview

!pip install ase

!pip install vtk
!pip install pyvista

import os

os.makedirs('/mnt/data/out/', exist_ok=True)

!pip install fastapi "uvicorn[standard]" pyngrok[ngrok] aiofiles python-multipart
# plus your ML deps, e.g. torch, transformers, tensorflow, etc.
!pip install torch torchvision transformers  # adjust as needed

import torch
import torch.nn as nn
import torch.nn.functional as F

# Define elements and related variables
ELEMENTS = ['H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P','S','Cl','Ar','K','Ca', # extend as needed
]
EL_TO_IDX = {e:i for i,e in enumerate(ELEMENTS)}
MAX_ATOMS = 64

# Define dummy values for N_ELEM and LATENT_DIM if they are not defined in the context
try:
    N_ELEM = len(ELEMENTS)
except NameError:
    N_ELEM = 20 # Or the appropriate number of elements you are considering

try:
    LATENT_DIM = 128 # Or your desired latent dimension
except NameError:
    LATENT_DIM = 128


class SpaceGroupEmbedding(nn.Module):
    def __init__(self, max_sg=230, emb_dim=64): # max_sg=230 for all space groups
        super().__init__()
        self.embed = nn.Embedding(max_sg+1, emb_dim)

    def forward(self, x):
        return self.embed(x)


class Encoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.sg_emb = SpaceGroupEmbedding()
        # encode lattice (flatten 9) + frac coords (MAX_ATOMS*3) + species one-hot (MAX_ATOMS*N_ELEM)
        in_dim = 9 + MAX_ATOMS*3 + MAX_ATOMS*N_ELEM
        self.fc1 = nn.Linear(in_dim + 64, 512)
        self.fc_mu = nn.Linear(512, LATENT_DIM)
        self.fc_logvar = nn.Linear(512, LATENT_DIM)


    def forward(self, lattice, frac, species_oh, sg_idx):
        # lattice: (B,3,3) -> (B,9)
        x = torch.cat([lattice.view(lattice.size(0), -1), frac.view(frac.size(0), -1), species_oh.view(species_oh.size(0), -1)], dim=-1)
        sg_e = self.sg_emb(sg_idx)
        x = torch.cat([x, sg_e], dim=-1)
        h = F.relu(self.fc1(x))
        return self.fc_mu(h), self.fc_logvar(h)


class Decoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.sg_emb = SpaceGroupEmbedding()
        out_dim = 9 + MAX_ATOMS*3 + MAX_ATOMS*N_ELEM
        self.fc1 = nn.Linear(LATENT_DIM + 64, 512)
        self.fc_out = nn.Linear(512, out_dim)


    def forward(self, z, sg_idx):
        sg_e = self.sg_emb(sg_idx)
        x = torch.cat([z, sg_e], dim=-1)
        h = F.relu(self.fc1(x))
        out = self.fc_out(h)
        # split to lattice, frac, species logits
        lattice = out[:, :9].view(-1,3,3)
        frac = out[:,9:9+MAX_ATOMS*3].view(-1,MAX_ATOMS,3)
        species_logits = out[:,9+MAX_ATOMS*3:].view(-1,MAX_ATOMS,N_ELEM)
        return lattice, frac, species_logits


class CVAE(nn.Module):
    def __init__(self):
        super().__init__()
        self.enc = Encoder()
        self.dec = Decoder()


    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5*logvar)
        eps = torch.randn_like(std)
        return mu + eps*std


    def forward(self, lattice, frac, species_oh, sg_idx):
        mu, logvar = self.enc(lattice, frac, species_oh, sg_idx)
        z = self.reparameterize(mu, logvar)
        lattice_rec, frac_rec, species_logits = self.dec(z, sg_idx)
        return lattice_rec, frac_rec, species_logits, mu, logvar


model_path = "/content/checkpoints/cvae_latest.pt" # Corrected path
model = CVAE() # Instantiate the model class
model.load_state_dict(torch.load(model_path, map_location="cpu"))  # or to 'cuda' if GPU available
model.eval()

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# cat > app.py <<'PY'
# from fastapi import FastAPI, File, UploadFile, Request
# from pydantic import BaseModel
# from fastapi.middleware.cors import CORSMiddleware
# import uvicorn
# import asyncio
# import json
# 
# app = FastAPI()
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],  # for dev prototype — narrow this in production
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )
# 
# class PredictRequest(BaseModel):
#     text: str
#     params: dict = {}
# 
# @app.post("/predict")
# async def predict(req: PredictRequest):
#     # Replace this with actual model inference
#     text = req.text
#     # synchronous or async inference depending on your model
#     out = {"received": text, "result": f"dummy result for {text}"}
#     return out
# 
# @app.post("/predict-file")
# async def predict_file(file: UploadFile = File(...)):
#     # Example for image/file -> model
#     content = await file.read()
#     # process content with model...
#     return {"filename": file.filename, "size": len(content)}
# 
# if __name__ == "__main__":
#     uvicorn.run(app, host="0.0.0.0", port=8000)
# PY
#

from pyngrok import ngrok, conf
# Optional: set your ngrok authtoken for stable tunnels
# conf.get_default().auth_token = "YOUR_NGROK_AUTHTOKEN"

# start tunnel
public_url = ngrok.connect(8000, "http")
print("Public URL:", public_url)
# then run the server in a background process
!python app.py &

"""To fix this error, you need to add your ngrok authtoken to Colab's Secrets and then configure `pyngrok` to use it.

1.  **Sign up for ngrok:** Go to [https://dashboard.ngrok.com/signup](https://dashboard.ngrok.com/signup) and create a free account.
2.  **Get your authtoken:** After signing up, go to [https://dashboard.ngrok.com/get-started/your-authtoken](https://dashboard.ngrok.com/get-started/your-authtoken) to find your authtoken.
3.  **Add to Colab Secrets:** In the left sidebar of Colab, click on the "🔑 Secrets" tab. Click "Add new secret", name it `NGROK_AUTH_TOKEN`, and paste your authtoken as the value.
"""

from google.colab import userdata
from pyngrok import ngrok, conf

# Set the ngrok authtoken from Colab secrets
conf.get_default().auth_token = userdata.get('NGROK_AUTH_TOKEN')

# Now you can connect to the tunnel
public_url = ngrok.connect(8000, "http")
print("Public URL:", public_url)

# Run the server in a background process
!python app.py &